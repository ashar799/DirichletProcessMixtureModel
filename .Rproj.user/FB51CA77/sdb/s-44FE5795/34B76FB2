{
    "contents" : "rm(list = ls())\nsetwd('/home/bit/ashar/Dropbox/Code/DPmixturemodel/DPplusAFT')\n#setwd(\"C:/Users/Oana-Ashar/Desktop/Dropbox/Code/DPmixturemodel/DPplusAFT\")\n\nlibrary(MASS)\nlibrary(mixtools)\nlibrary(matrixcalc)\nlibrary(stats)\nlibrary(Runuran)\nlibrary(truncnorm)\nlibrary(Matrix)\nlibrary(MCMCpack)\nlibrary(psych)\nlibrary(VGAM)\nlibrary(MixSim)\nlibrary(statmod)\nlibrary(flexclust)\nlibrary(survcomp)\nlibrary(mixAK)\nlibrary(mclust)\nlibrary(monomvn)\n\nA <- na.omit(airquality)\nN = nrow(A)\nY <- A[,2:4]\ntime <- A[,1]^(0.33)\ncensoring <- rep(1,N)\nD = ncol(Y)\n\n\nTime <-  cbind(time,censoring)\n\nK = as.integer(N/2)\n\nsource('rchinese.R')\n## Initialization of all the hyperparameters and \nshape.alpha <- 2\nrate.alpha <- 1\nalpha  = rgamma(1, shape = shape.alpha, rate = rate.alpha )\nbeta  = D+1\nro = 0.5\n\n## Empirical Bayes Estimate of the Hyperparameters\n\nepsilon = as.vector(apply(Y,2,mean))\nW = cov(Y)\nc <-  rchinese(N,alpha)\nf <- table(factor(c, levels = 1:max(c)))\n\n## Initialization of the parameters for Gaussian Mixture\nmu = matrix(data = NA, nrow = K, ncol = D)\nS = array(data = NA, dim =c(K,D,D))\n\n\n#Sparsity controlling parameter\nr =1\nsi = 1.78\n\nlambda2 <- numeric(K)\ntau2 = matrix(data = NA, nrow = K, ncol = D)\nbetahat = matrix(data = NA, nrow = K, ncol = D)\nsigma2 <- rep(NA, K)\nbeta0 <- rep(NA, K)\nThat <-  numeric(N)\n\n## Fitting a linear model to the whole model\nYsc <- scale(Y[1:N,1:D], center = TRUE, scale =TRUE)\nlm.data <- lm(time ~ Ysc)\nsig2.dat <-  var(lm.data$residuals)\n\n\n## Set Some Initial Values for the Cluster Parameters\n\nsource('priordraw.R')\ndisclass <- table(factor(c, levels = 1:K))\nactiveclass <- which(disclass!=0)\nfor ( j in 1:length(activeclass)){\n  \n  priorone <- priordraw(beta, W, epsilon, ro, r, si, N, D, sig2.dat)  \n  mu[activeclass[j],] <- priorone$mu\n  S[activeclass[j],1:D,1:D]  <- priorone$Sigma  \n  beta0[activeclass[j]] <- priorone$beta0 \n  sigma2[activeclass[j]] <- priorone$sigma2\n  betahat[activeclass[j],1:D] <- priorone$betahat \n  lambda2[activeclass[j]] <- priorone$lambda2 \n  tau2[activeclass[j], 1:D] <- priorone$tau2\n}\n\n# The Time has to be initialized\nsource('updatetime.R')\nti <- updatetime(c, Y, Time,That, beta0, betahat, sigma2)\nThat <- ti$time\n\nF =3\n\n\nsource('kmeansBlasso.R')\nkm <- kmeansBlasso(Y,That, F,K, beta, W, epsilon, ro, r, si, N, D, sig2.dat, c, mu, S, beta0, betahat, sigma2, lambda2, tau2)\nc.init <- km$c\nc <- c.init\nmu <- km$mu\nS <- km$S\nsigma2 <- km$sigma2\nbetahat <- km$betahat\nbeta0 <- km$beta0\nlambda2 <- km$lambda2\ntau2 <- km$tau2\n\nsource('posteriorchineseAFT.R')\nsource('posteriorGMMparametrs.R')\nsource('posteriortimeparameters.R')\nsource('updatetime.R')\nsource('priordraw.R')\nsource('likelihood.R')\nsource('posterioralpha.R') \n\ncognate <- NA\nparam <- NA\nparamtime <- NA\nloglike<- rep(0, iter)  \ntimeparam <- NA\ntime.predicted <- c(0)\ncindex <- c(0)\n\nprint(loglikelihood(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat) )\n\nlikli <- c(0)\nsili <- c(0)\nplogi <- c(0)\n\no.initi = o\niter.burnin = 1000\n\n\nprint(\"BURNIN...PHASE\")\nfor (o in o.initi:iter.burnin) {\n  ################## PARAMETERS OF THE DP Mixture Model ######################################################\n  ## Updating the parameters based on the observations \n  param <- posteriorGMMparametrs(c,Y,mu,S, alpha,K, epsilon, W, beta, ro,N,D )\n  mu <- param$mean\n  S <- param$precision\n  paramtime <- posteriortimeparameters(c, That, lambda2,tau2,sigma2,beta0, betahat, Y, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.data)\n  beta0 <- paramtime$beta0\n  betahat <- paramtime$betahat\n  sigma2 <- paramtime$sigma2\n  lambda2 <- paramtime$lambda2\n  tau2 <- paramtime$tau2\n  \n  ########################## THE HYPERPARAMETERS OF THE GMM #################################  \n  source('posteriorhyper.R')  \n  #  Updating the hyper paramters\n  hypercognate <- posteriorhyper (c, Y, mu, S, epsilon, W, beta, ro )\n  epsilon <- hypercognate$epsilon\n  tmpW <- hypercognate$W\n  W <- matrix(as.matrix(tmpW),nrow = D, ncol =D)\n  ro <- hypercognate$ro\n  \n  ################# INDICATOR VARIABLE ##################################################################\n  ## Updating the indicator variables and the parameters\n  source('posteriorchineseAFT.R')\n  cognate <- posteriorchineseAFT(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat)\n  c <- cognate$indicator\n  mu <- cognate$mean\n  S <- cognate$precision\n  beta0 <- cognate$beta0\n  betahat <- cognate$betahat\n  sigma2 <- cognate$sigma2\n  lambda2 <- cognate$lambda2\n  tau2 <- cognate$tau2\n  \n  ########################### The Concentration Parameter #################################################################\n  \n  \n  source('posterioralpha.R') \n  # Updating the concentration parameter\n  alpha <- posterioralpha(c, N, alpha, shape.alpha, rate.alpha)\n  \n  \n  \n  \n  \n  ######################## The Censored Times ###########################################################\n  source('updatetime.R')\n  # Updating the Time Variable\n  ti <- NA\n  ti <- updatetime(c, Y, Time,That, beta0, betahat, sigma2)\n  That <- ti$time\n  \n  \n  ##################### Print SOME Statistics #####################################################\n  \n  likli[o] <- loglikelihood(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat)\n  print(likli[o])\n  \n  print(o/iter.burnin)\n} \n\n\n## considering that we are now in the posterior region we can try to sample from the posterior and make predictions\n## We make predictions on a uniform Ystar in this case between 0 and 1\n\nN2 =  100\n\nx1star = c(runif(N2, 0, 1))\nx2star = mvrnorm(n = N2, mu = c(rep(0,dminus)), Sigma = diag(x =1, nrow = dminus, ncol = dminus))\n\nxstar = cbind(x1star,x2star)\n\nprint(\"POSTERIOR...PREDICTION\")\n\n\niter  = 200\nthin =  2\no =1\n\nalphamat <- matrix(0, nrow = 1, ncol = as.integer(iter/thin))\nbetahatmatrix1 <-  matrix(0, nrow = D, ncol = as.integer(iter/thin))\nbetahatmatrix2 <-  matrix(0, nrow = D, ncol = as.integer(iter/thin))\nbetahatmatrix3 <-  matrix(0, nrow = D, ncol = as.integer(iter/thin))\n\nNd = 200\nxstar = matrix(0, nrow = Nd, ncol =D)\nfor ( i in 1:D){\n  xstar[,i] <- as.vector(seq(from = min(Y[,i]), to = max(Y[,i]), by = (max(Y[,i]) - min(Y[,i]))/(Nd-1) ))\n}\n\n\nTstar <- matrix(0, nrow =Nd, ncol = as.integer(iter/thin))\n\nfor (o in 1:iter) {\n  ################## PARAMETERS OF THE DP Mixture Model ######################################################\n  ## Updating the parameters based on the observations \n  param <- posteriorGMMparametrs(c,Y,mu,S, alpha,K, epsilon, W, beta, ro,N,D )\n  mu <- param$mean\n  S <- param$precision\n  paramtime <- posteriortimeparameters(c, That, lambda2,tau2,sigma2,beta0, betahat, Y, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.data)\n  beta0 <- paramtime$beta0\n  betahat <- paramtime$betahat\n  sigma2 <- paramtime$sigma2\n  lambda2 <- paramtime$lambda2\n  tau2 <- paramtime$tau2\n  \n  ########################## THE HYPERPARAMETERS OF THE GMM #################################  \n  source('posteriorhyper.R')  \n  #  Updating the hyper paramters\n  hypercognate <- posteriorhyper (c, Y, mu, S, epsilon, W, beta, ro )\n  epsilon <- hypercognate$epsilon\n  tmpW <- hypercognate$W\n  W <- matrix(as.matrix(tmpW),nrow = D, ncol =D)\n  ro <- hypercognate$ro\n  \n  ################# INDICATOR VARIABLE ##################################################################\n  ## Updating the indicator variables and the parameters\n  source('posteriorchineseAFT.R')\n  cognate <- posteriorchineseAFT(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat)\n  c <- cognate$indicator\n  mu <- cognate$mean\n  S <- cognate$precision\n  beta0 <- cognate$beta0\n  betahat <- cognate$betahat\n  sigma2 <- cognate$sigma2\n  lambda2 <- cognate$lambda2\n  tau2 <- cognate$tau2\n  \n  ########################### The Concentration Parameter #################################################################\n  source('posterioralpha.R') \n  # Updating the concentration parameter\n  alpha <- posterioralpha(c, N, alpha, shape.alpha, rate.alpha)\n  \n  ######################## The Censored Times ###########################################################\n  source('updatetime.R')\n  # Updating the Time Variable\n  ti <- NA\n  ti <- updatetime(c, Y, Time,That, beta0, betahat, sigma2)\n  That <- ti$time\n  \n  \n  ##################### GEt the predictions after every thin iteration #####################################################\n  \n  source('predict.R')\n  if((o %% thin) == 0){\n    to <-  o/thin\n    \n    resultat <- predict(c, Y, That, Time, beta0, betahat, sigma2, xstar) \n    Tstar[,to]  <- resultat$tstar\n    betahatmatrix1[,to] <-  betahat[1,]\n    betahatmatrix2[,to] <- betahat[2,]\n    betahatmatrix3[,to] <- betahat[3,]\n    alphamat[to] <-  alpha\n  }\n  likli[o] <- loglikelihood(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat)\n  \n  \n  print(o/iter)\n} \n\n## Avergae Predictions\n\npostmat <- apply(Tstar,1,mean)\npostsd <- apply(Tstar,1,sd)\n\n  \npostbeta1 <- apply(betahatmatrix1,1,mean)\npostbeta2 <- apply(betahatmatrix2,1,mean)\npostbeta3 <- apply(betahatmatrix3,1,mean)\n\npostprobbeta1 <- rep(0, D)\npostprobbeta2 <- rep(0, D)\npostprobbeta3 <- rep(0, D)\n\n\nfor ( i in 1:D){\n  postprobbeta1[i] <- sum(betahatmatrix1[i,] !=0.000)/ncol(betahatmatrix1)\n}\nfor ( i in 1:D){\n  postprobbeta2[i] <- sum(betahatmatrix2[i,] !=0.000)/ncol(betahatmatrix2)\n}\nfor ( i in 1:D){\n  postprobbeta3[i] <- sum(betahatmatrix3[i,] !=0.000)/ncol(betahatmatrix3)\n}\ndats <- as.data.frame(cbind(time,Y))\n\n\ndatapost <- rbind(postprobbeta1,postprobbeta2, postprobbeta3)\nrownames(datapost)= c(\"cluster1\",\"cluster2\",\"cluster3\")\ncolnames(datapost)= c(\"solar\",\"wind\",\"temp\")\ndatabeta <- melt(datapost)\ncolnames(databeta) = c(\"cluster\",\"covariate\",\"post\")\n\np4 <- ggplot(databeta, aes(covariate, post, fill = cluster)) + \n  geom_bar(stat=\"identity\", position = \"dodge\") + \n  scale_fill_brewer(palette = \"Set1\") +\n  xlab(\"Covariates\") +\n  ylab(expression(p[post](gamma ))) +\n  ggtitle(\"Cluster Specific Posterior Probabilities\")\n\n\n\ncolnames(dats) <- c(\"ozone\",\"solar\",\"wind\",\"temp\")\n## Some plots\n\np1 <- ggplot(dats, aes(x= solar, y= ozone, color = factor(c))) +\n  geom_point() +\n  ggtitle(\"Ozone vs Solar\") +\n scale_color_manual(values = c(\"red\", \"blue\", \"green\"))\n\n# Second plot\np2 <- ggplot(dats, aes(x= wind, y=ozone, color =factor(c))) +\n   geom_point() +\n  ggtitle(\"Ozone vs wind\") +\n  scale_color_manual(values = c(\"red\", \"blue\", \"green\"))\n\n# Third plot\np3 <- ggplot(dats, aes(x= temp, y=ozone, color = factor(c))) +\n   geom_point() +\n  ggtitle(\"Ozone vs Temp\")+\n  scale_color_manual(values = c(\"red\", \"blue\", \"green\"))\n\n\npdf(\"Ozonedata.pdf\")\nsource('multiplot.R')\nmultiplot(p1, p2, p3, p4,cols=2)\ndev.off()\n\n\np8 <- ggplot() + ggtitle(\"Predicted Ozone values with error bars\") + geom_point(aes(x = xstar[,1], y = postmat)) + geom_errorbar(aes(x=xstar[,1], ymin=postmat-postsd, ymax=postmat+postsd), width=0.25) + geom_point(aes(x = Y[,1], y = time, color = factor(c)))+ scale_color_manual(values = c(\"red\", \"blue\", \"green\")) + labs(x = \"solar\", y= \"Ozone\")\n\n#### Simulate a lot of points using the second and third dimension\n\nnj = 10000\n## Now we generate proportional number of points\nn1j <- sum(c==1)/N\nn2j <- sum(c==2)/N\nn3j <- sum(c==3)/N\n\nN1j = as.integer(nj*n1j)\n\nxj1 <- rMVN(N1j,mean = mu[1,2:3], Q = S[1,2:3,2:3])\n\nN2j = as.integer(nj*n2j)\n\nxj2 <- rMVN(N2j,mean = mu[2,2:3], Q = S[2,2:3,2:3])\n\nN3j = as.integer(nj*n3j)\n\nxj3 <- rMVN(N3j,mean = mu[3,2:3], Q = S[3,2:3,2:3])\n\nxts <- rbind(xj1$x, xj2$x, xj3$x)\n\np10 <- ggplot(as.data.frame(xts),aes(x = xts[,1],y = xts[,2])) + geom_density2d(data = as.data.frame(xts))+ ggtitle(\"Predicted Density\") + xlab(\"Temperature\") + ylab(\"Wind\")\n  \np11 <- ggplot(as.data.frame(Y),aes(x = Y[,2],y = Y[,3], color = factor(c))) + geom_point() + ggtitle(\"Actual Points\") + xlab(\"Temperature\") + ylab(\"Wind\") + scale_color_manual(values = c(\"red\", \"blue\", \"green\"))\n\n## Saving the Plots\npdf(\"Ozone_conditional_Density\")\nmultiplot(p10,p11, cols =2)\ndev.off()\n\n## Predictive Density\npdf(\"Ozone_predictive_density\")\nplot(p8)\ndev.off()\n\n",
    "created" : 1433878916295.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2756193772",
    "id" : "34B76FB2",
    "lastKnownWriteTime" : 1433864676,
    "path" : "C:/Users/Oana-Ashar/Desktop/Dropbox/Code/DPmixturemodel/WindData/winddataset.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}