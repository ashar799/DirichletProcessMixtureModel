{
    "contents" : "posteriorchineseAFT = function(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat) {\n  \n  \n  Ytemp <- matrix(NA, nrow = N, ncol = D)\n  ctemp <- c\n  \n  ## This can't be parallelized !!!!!\n  for(l in 1:N)  {\n    \n    temp <- ctemp[l]\n    cminus <- ctemp\n    cminus[l] <- NA\n    ## The table function helps converting the data point specific indicator variables to class specific indicator variables\n    g <- table(factor(cminus, levels = 1:K))\n    active <- which(g!=0)\n    \n    \n    \n    kminus <- length(active)\n    ## Two Auxilary Variables\n    ## The name of the auxilary variables are taken to be one and two more than the maximum value in the already active cluster set\n    active <- append(active, max(active)+1)\n    active <- append(active, max(active)+1)\n    \n    \n    \n    ## If the observation was singelton (i.e no other point was associated with it then we assign to kminus +1 parameter)\n    if(length(which(cminus==temp))==0)  \n    {\n      ## The kminus+1 parameter gets the value of the temporary variable\n      ctemp[l] <- active[kminus+1]\n      mu[active[kminus+1],1:D] <- mu[temp,1:D]\n      S[active[kminus]+1,1:D,1:D] <- S[temp,1:D,1:D]\n      beta0[active[kminus+1]] <- beta0[temp]\n      betahat[active[kminus+1], 1:D] <- betahat[temp, 1:D]\n      sigma2[active[kminus+1]] <- sigma2[temp]\n      lambda2[active[kminus+1]] <- lambda2[temp]\n      tau2[active[kminus+1], 1:D] <- tau2[temp, 1:D]\n      \n      ## Also the second auxilary variable should be drawn from the prior distribution  \n      \n      source('priordraw.R')\n      priorone <- NA\n      priorone <- priordraw(beta, W, epsilon, ro, r, si,N,D, sig2.dat)\n      mu[active[kminus+2],1:D]  <- priorone$mu  \n      S[active[kminus+2],1:D,1:D]  <- priorone$Sigma  \n      beta0[active[kminus+2]] <- priorone$beta0 \n      sigma2[active[kminus+2]] <- priorone$sigma2\n      betahat[active[kminus+2],1:D] <- priorone$betahat \n      lambda2[active[kminus+2]] <- priorone$lambda2 \n      tau2[active[kminus+2], 1:D] <- priorone$tau2\n      \n      ## As we have to deal with centred matrices and if this point is alone in its cluster then\n      for ( k in 1:D){\n        Ytemp[l,k] <- 0\n      }\n      \n    } else {\n      \n      \n      \n      ## We have to deal with centred matrices\n      clust <- which(c == temp)\n      tempmatrix <- Y[clust,1:D]\n      sd.tempmatrix <- apply(tempmatrix, 2, function(x) sd(x))\n      mean.tempmatrix <- apply(tempmatrix, 2, mean)\n      \n      for ( k in 1:D){\n       if (sd.tempmatrix[k] == 0){\n         sd.tempmatrix[k] = 1\n       }\n      }\n      \n      for ( k in 1:D){\n        Ytemp[l,k] <- (Y[l,k] - mean.tempmatrix[k])/(sd.tempmatrix[k])\n      }\n      \n      source('priordraw.R')\n      priortwo <- NA\n      priortwo <- priordraw(beta, W, epsilon, ro, r, si,N,D, sig2.dat)\n      mu[active[kminus+1],1:D]  <- priortwo$mu  \n      S[active[kminus+1],1:D,1:D]  <- priortwo$Sigma[1:D,1:D]  \n      beta0[active[kminus+1]] <- priortwo$beta0 \n      sigma2[active[kminus+1]] <- priortwo$sigma2\n      betahat[active[kminus+1],1:D] <- priortwo$betahat \n      lambda2[active[kminus+1]] <- priortwo$lambda2 \n      tau2[active[kminus+1], 1:D] <- priortwo$tau2\n      \n      \n      source('priordraw.R')\n      priorthree <- NA\n      priorthree <- priordraw(beta, W, epsilon, ro, r, si,N,D, sig2.dat)\n      mu[active[kminus+2],1:D]  <- priorthree$mu  \n      S[active[kminus+2],1:D,1:D]  <- priorthree$Sigma[1:D,1:D]  \n      beta0[active[kminus+2]] <- priorthree$beta0 \n      sigma2[active[kminus+2]] <- priorthree$sigma2\n      betahat[active[kminus+2],1:D] <- priorthree$betahat \n      lambda2[active[kminus+2]] <- priorthree$lambda2 \n      tau2[active[kminus+2], 1:D] <- priorthree$tau2\n    }\n    \n    \n    \n    #######################################################\n    \n    \n    posterior <- matrix(NA, nrow = length(active), ncol = 1)\n    \n    \n    \n    \n    ## Calculating the probabalities for drawing the value of c_i from the active classes\n    for (j in 1:kminus) {\n      \n      posterior[j] <- g[active[j]] /(N-1+alpha) * dMVN(as.vector(t(Y[l,1:D])), mean = mu[active[j],1:D], Q = S[active[j],1:D,1:D]) *  dnorm(x = That[l], mean = beta0[active[j]] + betahat[active[j],1:D] %*% as.vector(t(Ytemp[l,1:D])), sd = sqrt(sigma2[active[j]]) )\n    }\n    \n    res <- try(dMVN(as.vector(t(Y[l,1:D])), mean = mu[active[kminus+1],1:D], Q= S[active[kminus+1],1:D,1:D]), silent=TRUE)\n    if (class(res) == \"try-error\"){\n       posterior[kminus+1] <- 0\n    } else{\n      posterior[kminus+1] <- (0.5 * alpha) /(N-1+alpha) * dMVN(as.vector(t(Y[l,1:D])), mean = mu[active[kminus+1],1:D], Q= S[active[kminus+1],1:D,1:D]) *  dnorm(x = That[l], mean = beta0[active[kminus+1]] + betahat[active[kminus+1],1:D] %*% as.vector(t(Ytemp[l,1:D])), sd = sqrt(sigma2[active[kminus+1]]) )\n    }\n    \n    res2 <- try(dMVN(as.vector(t(Y[l,1:D])), mean = mu[active[kminus+2],1:D], Q= S[active[kminus+2],1:D,1:D]), silent=TRUE)\n    if (class(res) == \"try-error\"){\n      posterior[kminus+2] <- 0\n    } else{\n      posterior[kminus+2] <- (0.5 * alpha) /(N-1+alpha) * dMVN(as.vector(t(Y[l,1:D])), mean = mu[active[kminus+2],1:D], Q = S[active[kminus+2],1:D,1:D]) *  dnorm(x = That[l], mean = beta0[active[kminus+2]] + betahat[active[kminus+2],1:D] %*% as.vector(t(Ytemp[l,1:D])), sd = sqrt(sigma2[active[kminus+2]]) )\n    }\n    \n    \n#     posterior[kminus+1] <- (0.5 * alpha) /(N-1+alpha) * dMVN(as.vector(t(Y[l,1:D])), mean = mu[active[kminus+1],1:D], Q= S[active[kminus+1],1:D,1:D]) *  dnorm(x = That[l], mean = beta0[active[kminus+1]] + betahat[active[kminus+1],1:D] %*% as.vector(t(Ytemp[l,1:D])), sd = sqrt(sigma2[active[kminus+1]]) )\n#     \n#     posterior[kminus+2] <- (0.5 * alpha) /(N-1+alpha) * dMVN(as.vector(t(Y[l,1:D])), mean = mu[active[kminus+2],1:D], Q = S[active[kminus+2],1:D,1:D]) *  dnorm(x = That[l], mean = beta0[active[kminus+2]] + betahat[active[kminus+2],1:D] %*% as.vector(t(Ytemp[l,1:D])), sd = sqrt(sigma2[active[kminus+2]]) )\n#     \n    \n    ## Calculating the normalization constant for probabilities\n    normalization <- sum(posterior) \n    \n    if (normalization < 1e-200){\n      ctemp[l] <- sample(active, 1, prob = rep(1,length(active)), replace = TRUE)\n    } else {  \n      ctemp[l] <- sample(active, 1, prob= posterior, replace = TRUE)\n    }\n    \n  }\n  \n  c <- ctemp\n  ## Delete those observations that are not associcated with no data point\n  g <- table(factor(c, levels = 1:K))\n  inactive <- which(g==0)\n  \n  for ( i in 1:length(inactive)){\n    mu[inactive[i],1:D]  <- NA \n    S[inactive[i],1:D,1:D]  <- NA  \n    beta0[inactive[i]] <- NA \n    sigma2[inactive[i]] <- NA\n    betahat[inactive[i],1:D] <- NA \n    lambda2[inactive[i]] <- NA\n    tau2[inactive[i], 1:D] <- NA\n  }\n  \n  \n  \n  list('indicator' = c,'mean' = mu,'precision' = S,  'beta0' = beta0,'betahat2'= betahat, 'sigma2'=sigma2, 'lambda2'= lambda2, 'tau2' = tau2)\n  \n}\n",
    "created" : 1433875947348.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1929908812",
    "id" : "87158B43",
    "lastKnownWriteTime" : 1433845513,
    "path" : "C:/Users/Oana-Ashar/Desktop/Dropbox/Code/DPmixturemodel/DPplusAFT/posteriorchineseAFT.R",
    "project_path" : "posteriorchineseAFT.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}