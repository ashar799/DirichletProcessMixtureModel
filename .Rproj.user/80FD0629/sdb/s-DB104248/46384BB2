{
    "contents" : "### Practical Application##############################\nrm (list = ls())\nsetwd(\"/home/bit/ashar/Dropbox/Pathway\")\nload('30pathway.RData')\n\nlibrary(MASS)\nlibrary(mixtools)\nlibrary(matrixcalc)\nlibrary(stats)\nlibrary(Runuran)\nlibrary(truncnorm)\nlibrary(Matrix)\nlibrary(MCMCpack)\nlibrary(psych)\nlibrary(VGAM)\nlibrary(MixSim)\nlibrary(statmod)\nlibrary(flexclust)\nlibrary(survcomp)\nlibrary(mixAK)\nlibrary(mclust)\nlibrary(monomvn)\n\n\nexprs.norm <- data.combined\n\n## Number of points\nN = nrow(data.combined)\n\n## Read the phenoData\n## REad PhenoData and Log transform it\nlibrary('xlsx')\npheno <- read.xlsx(\"survival.xls\", sheetIndex =1)\npheno[,1] <- as.character(as.matrix(pheno[,1]))\nmt <- match(rownames(exprs.norm),pheno[,1])\npheno <- pheno[mt,] \ntemplog <- as.numeric(as.vector(pheno[,3]))\ntemplog <- log(templog)\npheno[,3] <- templog\n\n## Expected Number of Clusters\nF = 4\n\n## Distribution of the points within three clusters\n\n## Total Number of features D\n\nD = ncol(exprs.norm)\n\n\n\n############################################### MAKING Y from the clusters data #####################3\n\nY <- as.matrix(exprs.norm)\n\n#######################################MAKING TIME from cluster data ########################################################\n\ntime <- pheno[,3]\n\n####################################### Adding CENSORING INFORMATION  ################################################################\n## Adding the censoring information\n\ncensoring <- pheno[,2]\n\n\n### A little Visualization of the Y Data ##############\npc <- prcomp(Y)\npc.pred <- predict(pc,newdata = Y)\nplot(pc.pred[,1], pc.pred[,2], pch = 19,)\n\n\n############################# PARAMETERS for GIBB's SAMPLING ######################################\n\niter = 500\niter.burnin = 100\niter.thin  = 20\n\n################################# GIBBS SAMPLING  ###################################################\n\nTime <- cbind(time, censoring) \n\nK =  10\n\n## HYPER PRIORS\n## Hyper parameters of the DP\nshape.alpha <- 2\nrate.alpha <- 1\n## Hyperparameters for the GMM\nbeta  = D+2\nro = 0.5\n\nsetwd('/home/bit/ashar/Dropbox/Code/DPmixturemodel/DPplusAFT')\n\nsource('rchinese.R')\nalpha  = rgamma(1, shape = shape.alpha, rate = rate.alpha )\nc <-  rchinese(N,alpha)\nf <- table(factor(c, levels = 1:max(c)))\n\n## Empirical Bayes Estimate of the Hyperparameters\nepsilon = as.vector(apply(Y,2,mean))\nW = cov(Y)\n\n\n## Initialization of the parameters for Gaussian Mixture\nmu = matrix(data = NA, nrow = K, ncol = D)\nS = array(data = NA, dim =c(K,D,D))\n\n\n#Sparsity controlling hyperparameter of the BAYESIAN LASSO MODEL\nr =1\nsi = 1.78\n\nlambda2 <- numeric(K)\ntau2 = matrix(data = NA, nrow = K, ncol = D)\nbetahat = matrix(data = NA, nrow = K, ncol = D)\nsigma2 <- rep(NA, K)\nbeta0 <- rep(NA, K)\nThat <-  numeric(N)\n\n## Fitting a linear model to the whole model\nYsc <- scale(Y[1:N,1:D], center = TRUE, scale =TRUE)\nlm.data <- lm(time ~ Ysc)\nsig2.dat <-  var(lm.data$residuals)\n\n\n## Set Some Initial Values for the Cluster Parameters\n\nsource('priordraw.R')\ndisclass <- table(factor(c, levels = 1:K))\nactiveclass <- which(disclass!=0)\nfor ( j in 1:length(activeclass)){\n  \n  priorone <- priordraw(beta, W, epsilon, ro, r, si, N, D, sig2.dat)  \n  mu[activeclass[j],] <- (priorone$mu) \n  S[activeclass[j],1:D,1:D]  <- priorone$Sigma  \n  beta0[activeclass[j]] <- priorone$beta0 \n  sigma2[activeclass[j]] <- priorone$sigma2\n  betahat[activeclass[j],1:D] <- priorone$betahat \n  lambda2[activeclass[j]] <- priorone$lambda2 \n  tau2[activeclass[j], 1:D] <- priorone$tau2\n}\n\n# The Time has to be initialized\nsource('updatetime.R')\nti <- updatetime(c, Y, Time,That, beta0, betahat, sigma2)\nThat <- ti$time\n\n\nF <- 4\n\n## Initialization part for the parmaters of AFT Model with k-means and Bayesian Lasso\nsource('kmeansBlasso.R')\nkm <- kmeansBlasso(Y,That, F,K, beta, W, epsilon, ro, r, si, N, D, sig2.dat, c, mu, S, beta0, betahat, sigma2, lambda2, tau2)\nc <- km$c\nmu <- km$mu\nS <- km$S\nsigma2 <- km$sigma2\nbetahat <- km$betahat\nbeta0 <- km$beta0\nlambda2 <- km$lambda2\ntau2 <- km$tau2\n\n\n\n# Testing the  k-means estimate\nsource('predicttime.R')\ntime.predicted <- predicttime(c,Y, That,Time,beta0, betahat, sigma2)$predicttime\n\n\n## Prelimnary estimates of the RAND and C-INDEX index\nsource('calcindex.R')\ncindex <- calcindex(c,Time,time.predicted)$cindex\n\n## Adjusted Rand INDEX measure\n##randindex <- adjustedRandIndex(c.true,as.factor(c))\n\n\n\n\n## Gibb's sampling \n\nsource('posteriorchineseAFT.R')\nsource('posteriorGMMparametrs.R')\nsource('posteriortimeparameters.R')\nsource('updatetime.R')\nsource('priordraw.R')\nsource('likelihood.R')\n\n\ncognate <- NA\nparam <- NA\nparamtime <- NA\nloglike<- rep(0, iter)  \ntimeparam <- NA\ntime.predicted <- c(0)\ncindex <- c(0)\n\nprint(loglikelihood(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat) \n\n\n#################### BURNIN PHASE ###################################################\nprint(\"BURNIN...PHASE\")\nfor (o in 1:iter.burnin) {\n  \n  \n  ################## PARAMETERS OF THE DP Mixture Model ######################################################\n  ## Updating the parameters based on the observations \n  param <- posteriorGMMparametrs(c,Y,mu,S, alpha,K, epsilon, W, beta, ro,N,D )\n  mu <- param$mean\n  S <- param$precision\n  paramtime <- posteriortimeparameters(c, That, lambda2,tau2,sigma2,beta0, betahat, Y, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.data)\n  beta0 <- paramtime$beta0\n  betahat <- paramtime$betahat\n  sigma2 <- paramtime$sigma2\n  lambda2 <- paramtime$lambda2\n  tau2 <- paramtime$tau2\n  \n  ########################## THE HYPERPARAMETERS OF THE GMM #################################  \n  #   source('posteriorhyper.R')  \n  #   #  Updating the hyper paramters\n  #     hypercognate <- posteriorhyper (c, Y, mu, S, epsilon, W, beta, ro )\n  #     epsilon <- hypercognate$epsilon\n  #     W <- hypercognate$W\n  #     W <- matrix(as.matrix(W),nrow = D, ncol =D)\n  #     ro <- hypercognate$ro\n  #     \n  ################# INDICATOR VARIABLE ##################################################################\n  ## Updating the indicator variables and the parameters\n  source('posteriorchineseAFT.R')\n  cognate <- posteriorchineseAFT(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat)\n  c <- cognate$indicator\n  mu <- cognate$mean\n  S <- cognate$precision\n  beta0 <- cognate$beta0\n  betahat <- cognate$betahat\n  sigma2 <- cognate$sigma2\n  lambda2 <- cognate$lambda2\n  tau2 <- cognate$tau2\n  \n  ########################### The Concentration Parameter #################################################################\n  \n  \n  #source('posterioralpha.R') \n  ## Updating the concentration parameter\n  # alpha <- posterioralpha(c, N, alpha, shape.alpha, rate.alpha)\n  \n  \n  ######################## The Censored Times ###########################################################\n  source('updatetime.R')\n  # Updating the Time Variable\n  ti <- NA\n  ti <- updatetime(c, Y, Time,That, beta0, betahat, sigma2)\n  That <- ti$time\n  \n  \n  print(o/iter.burnin)\n} \n\n############## GIBBS SAMPLING WITH THINNING ######################################################\n\nmu.list <- list(0)\nbeta0.list <- list(0)\nbetahat.list <- list(0) \nsigma2.list <- list(0)\nlambda2.list <- list(0)\ntau2.list <- list(0)\nc.list <- list(0)\nThat.list <- list(0)\n\nnumber.cluster <- c(0)\n\n\nprint(\"GIBB'S SAMPLING\")\ncount = 1\nfor (o in 1:iter) {\n  \n  \n  ################## PARAMETERS OF THE DP Mixture Model ######################################################\n  ## Updating the parameters based on the observations \n  param <- posteriorGMMparametrs(c,Y,mu,S, alpha,K, epsilon, W, beta, ro,N,D )\n  mu <- param$mean\n  S <- param$precision\n  paramtime <- posteriortimeparameters(c, That, lambda2,tau2,sigma2,beta0, betahat, Y, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.data)\n  beta0 <- paramtime$beta0\n  betahat <- paramtime$betahat\n  sigma2 <- paramtime$sigma2\n  lambda2 <- paramtime$lambda2\n  tau2 <- paramtime$tau2\n  \n  ########################## THE HYPERPARAMETERS OF THE GMM #################################  \n  #   source('posteriorhyper.R')  \n  #   #  Updating the hyper paramters\n  #     hypercognate <- posteriorhyper (c, Y, mu, S, epsilon, W, beta, ro )\n  #     epsilon <- hypercognate$epsilon\n  #     W <- hypercognate$W\n  #     W <- matrix(as.matrix(W),nrow = D, ncol =D)\n  #     ro <- hypercognate$ro\n  #     \n  ################# INDICATOR VARIABLE ##################################################################\n  ## Updating the indicator variables and the parameters\n  source('posteriorchineseAFT.R')\n  cognate <- posteriorchineseAFT(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat)\n  c <- cognate$indicator\n  mu <- cognate$mean\n  S <- cognate$precision\n  beta0 <- cognate$beta0\n  betahat <- cognate$betahat\n  sigma2 <- cognate$sigma2\n  lambda2 <- cognate$lambda2\n  tau2 <- cognate$tau2\n  \n  ########################### The Concentration Parameter #################################################################\n  \n  \n  #source('posterioralpha.R') \n  ## Updating the concentration parameter\n  # alpha <- posterioralpha(c, N, alpha, shape.alpha, rate.alpha)\n  \n  \n  ######################## The Censored Times ###########################################################\n  source('updatetime.R')\n  # Updating the Time Variable\n  ti <- NA\n  ti <- updatetime(c, Y, Time,That, beta0, betahat, sigma2)\n  That <- ti$time\n  \n  \n  \n  #   ## Value of the predicted p-value\n  #   source('predicttime.R') \n  #   time.predicted <- predicttime(c, Y, That, Time, beta0, betahat, sigma2)$predicttime\n  #   #  pval <- ks.test(That, time.predicted$predicttime, alternative = \"two.sided\" )$p.value\n  #   source('calcindex.R')\n  #   cindex <- calcindex(c,Time,time.predicted)$cindex\n  #   ## Value of the Log-likelihood\n  source('likelihood.R')\n  loglike[o] <-loglikelihood(c,Y,mu,S,alpha,That, beta0, betahat, sigma2, lambda2, tau2, K, epsilon, W, beta, ro,D, r, si, Time,N, sig2.dat) \n  \n  if(o%% iter.thin == 0 ){\n    mu.list[[count]] <- mu\n    beta0.list[[count]] <- beta0\n    betahat.list[[count]] <- betahat  \n    sigma2.list[[count]] <- sigma2\n    lambda2.list[[count]] <- lambda2\n    tau2.list[[count]] <- tau2\n    c.list[[count]] <- c\n    That.list[[count]] <- That\n    count <- count +1\n   }\n  \n  \n  disclass <- table(factor(c, levels = 1:K))\n  number.cluster[o] <- length(which(disclass!=0))\n  \n  \n  \n  print(o/iter) \n  #   print(loglike[o])\n  #   print(cindex)\n} \n\n########## ANLAYSING THE OUTPUT #######################################################\n\ncount <- count -1\n\n## Selecting that clustering which gives the maximum RAND INDEX\nri <- 1:count\n\n\ndisclass <- table(factor(c, levels = 1:K))\nactiveclass <- which(disclass!=0)\n\n\n## Prelimnary estimates of the RAND and C-INDEX index\nsource('calcindex.R')\ncindex.final <- calcindex(c.final,Time,time.predicted.final)$cindex\n\n\nc1 <- c(0)\nc2 <- c(0)\n\nfor ( i in 1:count){\n  time.pr <- predicttime(c.list[[i]],Y, That.list[[i]],Time, beta0.list[[i]], betahat.list[[i]], sigma2.list[[i]])$predicttime\n  c1[i] <-  calcindex(c.list[[i]],Time,time.pr)$cindex[1]\n  c2[i] <-  calcindex(c.list[[i]],Time,time.pr)$cindex[2]\n \n}\n\npdf('/home/bit/ashar/Dropbox/WarsawTalk/BoxplotsVerhark.pdf')\nboxplot(c1,c2, names = c(\"C-Ind1\",\"C-Ind2\"), main = \" Concordance Index for Verhaark Data\")\nleg.text <- c(\"samples = 196\", \"Cluster1 =29\", \"Cluster2 =  167\", \"relevant.dims = 0\")\nlegend(\"bottomright\", leg.text)\ndev.off()\n\n \nind <- (c == 4) | (c==5)\nc[ind] <- 2\n\nc.final <- c\n\nsurv.ob <- Surv(Time[,1],Time[,2])\nsurv.fit <- survfit(surv.ob ~ c.final)\nlogrank <- survdiff(surv.ob ~ c.final)\n\n\npdf('/home/bit/ashar/Dropbox/WarsawTalk/KaplanMeierVerhaark.pdf')\nplot(surv.fit, col = c(\"blue\", \"green\"))\ntitle(\"Kaplan-Meier Curves\\nfor the Verhaark data\")\nleg.text <- c(\"p-value of 0.085\")\nlegend(\"topright\", leg.text)\ndev.off()\n\n\n## Ploting a PCA\n\npc <- prcomp(Y)\npdf('/home/bit/ashar/Dropbox/WarsawTalk/PCAVerhaark.pdf')\npc.pred <- predict(pc,newdata = Y)\nplot(pc.pred[,1], pc.pred[,2], pch = 19, col =c(\"red\",\"blue\",\"green\")[c.final], xlab = \"PC1\", ylab = \"PC2\")\ntitle(\"PCA plot for Verhaark data\")\ndev.off()\n\n",
    "created" : 1428491967518.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "263686109",
    "id" : "46384BB2",
    "lastKnownWriteTime" : 1428511541,
    "path" : "~/Dropbox/Pathway/pathwayMODEL.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}