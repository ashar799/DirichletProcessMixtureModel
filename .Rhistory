rcorr.cens(invers.predict, surv.aft)
rcorr.cens(predict(fit), surv.aft)
survConcordance(surv.aft ~ invers.predict)
?cox.ph()
coxph()
?coxph()
fit.coxph <- coxph(surv.aft ~ X.sc.aft[,1:5] )
predict(fit.coxph)
predict(fit)
summary(fit.coxph)
survConcordance(surv.aft ~ predict(fit.coxph))
rcorr.cens(predict(fit.coxph), surv.aft)
rcorr.cens(exp(-predict(fit.coxph)), surv.aft)
survConcordance(surv.aft ~ invers.predict)
cbind(time.mu,predict(fit))
rcorr.cens(time.mu, surv.aft)
rcorr.cens(predict(fit), surv.aft)
library(Hmsic)
library(Hmisc)
final.cindex <- rcorr.cens(tem.tim, surv.aft)
setwd('/home/bit/ashar/Dropbox/Code/DPmixturemodel/DPplusAFT')
library(MASS)
library(mixtools)
library(matrixcalc)
library(stats)
library(Runuran)
library(truncnorm)
library(Matrix)
library(MCMCpack)
library(psych)
library(VGAM)
library(MixSim)
library(statmod)
library(flexclust)
library(mixAK)
library(mclust)
library(monomvn)
library(cluster)
library(flexmix)
library(survival)
library(utils)
library(rms)
library(pec)
library(ipred)
setwd('/home/bit/ashar/Dropbox/Code/DPmixturemodel/DPplusAFT')
library(MASS)
library(mixtools)
library(matrixcalc)
library(stats)
library(Runuran)
library(truncnorm)
library(Matrix)
library(MCMCpack)
library(psych)
library(VGAM)
library(MixSim)
library(statmod)
library(flexclust)
library(mixAK)
library(mclust)
library(monomvn)
library(cluster)
library(flexmix)
library(survival)
library(utils)
library(rms)
library(pec)
library(ipred)
### Remove The Past
rm(list = ls())
#################################### SIMULATED DATA PROPERTIES ####################################################
## Number of points
N.test = 100
N.train =100
N = N.test + N.train
## Number of Clusters
F = 3
## Distribution of the points within three clusters
p.dist = c(0.4,0.3,0.3)
## Total Number of features D
D = 10
## Total Percentage of irrelevant feature
prob.noise.feature = 0.6
## Total Percentage of censoring
prob.censoring = 0.10
## Overlap between Cluster of molecular Data of the relevant features
prob.overlap = 0.01
## Percentage of Noise/Overlap in Time Data
prob.noise = 0.1
############################# PARAMETERS for GIBB's SAMPLING ####
iter = 100
iter.burnin = 60
iter.thin  =5
k =3
########################### Initialize the functions ############
source('simulateDPMM.R')
simulateDPMM()
source('initializeDPMM.R')
initializeDPMM()
gr.km <- kmeans(Y, 2, nstart =10)
adjustedRandIndex(c.true,as.factor(gr.km$cluster))
brier.km <- c(0)
brier.aft <- c(0)
brier.cox <- c(0)
i =1
ind <- which((gr.km$cluster) == i)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
rownames(Y.tmp) <- as.character(c(1:nrow(Y.tmp)))
L = length(ind)
f1 <- psm(smod ~ Y.tmp , dist="lognormal")
smod <-  Surv(exp(time.tmp), censoring.tmp)
f1 <- psm(smod ~ Y.tmp , dist="lognormal")
S1 <- Survival(f1)
S1
?psm()
?brier()
library(verification)
install.packages(verification)
install.packages('verification')
library(verification)
library(verification)
?brier()
setwd('/home/bit/ashar/Dropbox/Code/DPmixturemodel/DPplusAFT')
library(MASS)
library(mixtools)
library(matrixcalc)
library(stats)
library(Runuran)
library(truncnorm)
library(Matrix)
library(MCMCpack)
library(psych)
library(VGAM)
library(MixSim)
library(statmod)
library(flexclust)
library(mixAK)
library(mclust)
library(monomvn)
library(cluster)
library(flexmix)
library(survival)
library(utils)
library(rms)
library(pec)
library(ipred)
library(verification)
rm(list = ls())
#################################### SIMULATED DATA PROPERTIES ####################################################
## Number of points
N.test = 100
N.train =100
N = N.test
## Number of Clusters
F = 3
## Distribution of the points within three clusters
p.dist = c(0.4,0.3,0.3)
## Total Number of features D
D = 10
## Total Percentage of irrelevant feature
prob.noise.feature = 0.6
## Total Percentage of censoring
prob.censoring = 0.10
## Overlap between Cluster of molecular Data of the relevant features
prob.overlap = 0.01
## Percentage of Noise/Overlap in Time Data
prob.noise = 0.1
############################# PARAMETERS for GIBB's SAMPLING ####
iter = 100
iter.burnin = 60
iter.thin  =5
k =3
source('simulateDPMM.R')
simulateDPMM()
source('initializeDPMM.R')
initializeDPMM()
gr.km <- kmeans(Y, F, nstart =10)
gr.km.rand <- adjustedRandIndex(c.true,as.factor(gr.km$cluster))
gr.km.rand
?coxph()
smod <-  Surv(exp(time), censoring)
smod
fit.cox.km <- coxph(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)), data = as.data.frame(Y))
fit.cox.km
predict(fit.cox.km)
survConcordance(smod ~ predict(fit.cox.km))
?survfit()
fit.coxph <- survfit(fit.cox.km, newdata = as.data.frame(Y[,1:D]))
fit.coxph
brier.km.cox <- crps(pec(list("CoxPH"=fit.coxph),data= as.data.frame(Y),formula=Surv(exp(time), censoring) ~ Y))[[2]]
?crps()
?pec()
?survfit()
fit.coxph$strata
pec(list("CoxPH"=fit.coxph),data= as.data.frame(Y),formula=Surv(exp(time), censoring) ~ Y)
?pec()
crps(pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula=Surv(exp(time), censoring) ~ Y))[[2]]
pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula=Surv(exp(time), censoring) ~ Y))
pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula=Surv(exp(time), censoring) ~ Y)
crps(pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula= smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster))))[[2]]
pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula= smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)))
pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula= smod ~ Y+ strata(as.factor(gr.km$cluster)))
smod
brier.km.cox <- crps(pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula= smod ~ Y )[[2]]
)
predict(fit.cox.km)
predictSurvProb(fit.cox.km)
predictSurvProb(object =fit.cox.km, newdata = Y, times = exp(time))
predictSurvProb(object =fit.cox.km, times = exp(time))
predictSurvProb(object =fit.cox.km, newdata = Y[,1:Dtimes = exp(time))
predictSurvProb(object =fit.cox.km, newdata = Y[,1:D],times = exp(time))
predictSurvProb(object =fit.cox.km, newdata =as.data.frame(Y[,1:D]),times = exp(time))
exp(time)
SimSurv(100)
library(prodlim)
d <- SimSurv(100)
d
quantile(d$time)
predictSurvProb(object =fit.cox.km, newdata =as.data.frame(Y),times = exp(time))
exp(time)
qunatile(exp(time))
quntile(exp(time))
quantile(exp(time))
predictSurvProb(object =fit.cox.km, newdata =as.data.frame(Y),times = quantile(exp(time)))
lenth(time)
length(time)
quantile(exp(time))
as.vector(quantile(exp(time)))
predictSurvProb(object =fit.cox.km, newdata =as.data.frame(Y),times = as.vector(quantile(exp(time))))
fit.cox.km
smod
quantile(smod)
quantile(smod[,1])
pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula= smod ~ 1 )
pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula= Surv(exp(time), censoring) ~ 1 )
pec(list("CoxPH"=fit.cox.km),data= as.data.frame(Y),formula= Surv(exp(time), censoring) ~ 1, times = exp(time) )
fit.aft.km <- survreg(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)) , dist="lognormal")
library(Hmisc)
rcorr.cens(predict(fit.aft.km), smod)
rcorr.cens(predict(fit.aft.km), smod)["C-Index"]
rcorr.cens(predict(fit.aft.km), smod)[1]
fit.aft <- survfit(fit.aft.km, newdata = as.data.frame(Y[,1:D]))
?psm()
f1 <- psm(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster) , dist="lognormal")
)
f1 <- psm(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)) , dist="lognormal")
f1 <- psm(smod ~ Y[,1:D]  , dist="lognormal")
q =1
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
rownames(Y.tmp) <- as.character(c(1:nrow(Y.tmp)))
smod.tmp <-  Surv(exp(time.tmp), censoring.tmp)
f1 <- psm(smod.tmp ~ Y.tmp[,1:D]  , dist="lognormal")
S1 <- Survival(f1)
L = length(ind)
mat.tmp <- matrix(NA, nrow = L, ncol = L)
for (j in 1:L){
mat.tmp[,j] <- S1(exp(time.tmp[j]),f1$linear.predictors)
}
sbrier(smod.tmp,mat.tmp,exp(time.tmp))[1]
q =1
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
rownames(Y.tmp) <- as.character(c(1:nrow(Y.tmp)))
smod.tmp <-  Surv(exp(time.tmp), censoring.tmp)
fit.km <- coxph(smod.tmp ~ Y.tmp[,1:D], data = as.data.frame(Y.tmp))
length(L)
length(index)
length(ind)
dim(Y.tmp)
fit.km
q =2
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
rownames(Y.tmp) <- as.character(c(1:nrow(Y.tmp)))
smod.tmp <-  Surv(exp(time.tmp), censoring.tmp)
fit.km <- coxph(smod.tmp ~ Y.tmp[,1:D], data = as.data.frame(Y.tmp))
crps(pec(list("CoxPH"=fit.km),data= as.data.frame(Y.tmp),formula= smod.tmp ~ Y.tmp[,1:D], times = exp(time.tmp) )
)
predictSurv()
predSurvprob()
survfit(fit.km)
?survfit.coxph
survfit(fit.km, newdata = as.data.frame(Y.tmp))
smod <-  Surv(exp(time.tmp), censoring.tmp)
f2 <-   coxph(smod ~ Y.tmp, data = as.data.frame(Y.tmp))
crps(pec(list("CoxPH"=f2),data= as.data.frame(Y.tmp),formula=Surv(exp(time.tmp), censoring.tmp) ~ Y.tmp))[[2]]
?pec()
pec(list("CoxPH"=fit.km),data= as.data.frame(Y.tmp),formula= smod.tmp ~ Y.tmp[,1:D], times = exp(time.tmp))
pec(list("CoxPH"=fit.km),data= as.data.frame(Y.tmp),formula= smod.tmp ~ Y.tmp, times = exp(time.tmp))
fit.km
dim(Y.tmp)
pec(list("CoxPH"=fit.km),data= as.data.frame(Y.tmp),formula= smod.tmp ~ 1, times = exp(time.tmp))
?survfit()
q =1
q =2
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
rownames(Y.tmp) <- as.character(c(1:nrow(Y.tmp)))
smod.tmp <-  Surv(exp(time.tmp), censoring.tmp)
fit.km <- coxph(smod.tmp ~ Y.tmp[,1:D], data = as.data.frame(Y.tmp))
survfit(fit.km, newdata = as.data.frame(Y.tmp),individual = TRUE)
survfit.object
?survfit.object
survival.km <- survfit(fit.km, newdata = as.data.frame(Y.tmp))
survivival.km$strata
survival.km$strata
survival.km$surv
survival.km$time
fit.cox.km <- coxph(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)), data = as.data.frame(Y))
fit.coxph <- survfit(fit.cox.km, newdata = as.data.frame(Y[,1:D]))
fit.cox.km <- coxph(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)), data = as.data.frame(Y))
smod <-  Surv(exp(time), censoring)
fit.cox.km <- coxph(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)), data = as.data.frame(Y))
fit.coxph <- survfit(fit.cox.km, newdata = as.data.frame(Y[,1:D]))
fit.coxph$surv
fit.coxph$time
?sbrier
sbrier(smod,pred = fit.coxp)
sbrier(smod,pred = fit.coxph)
sbrier(smod,pred = list("COXPH" =fit.coxph))
fit.coxph$time
fit.coxph$n.event
Surv(fit.coxph$time,fit.coxph$n.event)
sbrier(Surv(fit.coxph$time,fit.coxph$n.event), fit.coxph$surv)
fit.coxph$strata
sbrier(Surv(fit.coxph$time,fit.coxph$n.event), fit.coxph$surv)[[1]]
fit.cox.km <- coxph(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)), data = as.data.frame(Y))
## C-Index
cindex.km.cox <- survConcordance(smod ~ predict(fit.cox.km))
## Brier Score
fit.coxph <- survfit(fit.cox.km, newdata = as.data.frame(Y[,1:D]))
brier.km.cox <- sbrier(Surv(fit.coxph$time,fit.coxph$n.event), fit.coxph$surv)[[1]]
brier.km.cox
fit.aft <- survfit(fit.aft.km, newdata = as.data.frame(Y[,1:D]))
?survfit
fit.aft.km <- survreg(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)) , dist="lognormal")
cindex.km.aft <- rcorr.cens(predict(fit.aft.km), smod)[1]
### Brier Score
brier.km.aft <- c(0)
for ( q in 1:F){
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
rownames(Y.tmp) <- as.character(c(1:nrow(Y.tmp)))
smod.tmp <-  Surv(exp(time.tmp), censoring.tmp)
f1 <- psm(smod.tmp ~ Y.tmp[,1:D]  , dist="lognormal")
S1 <- Survival(f1)
L = length(ind)
mat.tmp <- matrix(NA, nrow = L, ncol = L)
for (j in 1:L){
mat.tmp[,j] <- S1(exp(time.tmp[j]),f1$linear.predictors)
}
brier.km.aft[q] <- sbrier(smod.tmp,mat.tmp,exp(time.tmp))[1]
}
brier.km.aft
smod <-  Surv(exp(time), censoring)
#############################################
########### K-means #########################
#############################################
#############################################
gr.km <- kmeans(Y, F, nstart =10)
gr.km.rand <- adjustedRandIndex(c.true,as.factor(gr.km$cluster))
########## CoxPH #############################
fit.cox.km <- coxph(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)), data = as.data.frame(Y))
## C-Index
cindex.km.cox <- survConcordance(smod ~ predict(fit.cox.km))
## Brier Score
fit.coxph <- survfit(fit.cox.km, newdata = as.data.frame(Y[,1:D]))
brier.km.cox <- sbrier(Surv(fit.coxph$time,fit.coxph$n.event), fit.coxph$surv)[[1]]
######## AFT ###################################
fit.aft.km <- survreg(smod ~ Y[,1:D] + strata(as.factor(gr.km$cluster)) , dist="lognormal")
cindex.km.aft <- rcorr.cens(predict(fit.aft.km), smod)[1]
### Brier Score
brier.km.aft <- c(0)
for ( q in 1:F){
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
rownames(Y.tmp) <- as.character(c(1:nrow(Y.tmp)))
smod.tmp <-  Surv(exp(time.tmp), censoring.tmp)
f1 <- psm(smod.tmp ~ Y.tmp[,1:D]  , dist="lognormal")
S1 <- Survival(f1)
L = length(ind)
mat.tmp <- matrix(NA, nrow = L, ncol = L)
for (j in 1:L){
mat.tmp[,j] <- S1(exp(time.tmp[j]),f1$linear.predictors)
}
brier.km.aft[q] <- sbrier(smod.tmp,mat.tmp,exp(time.tmp))[1]
}
cindex.km.cox
cindex.km.aft
brier.km.aft
brier.km.cox
source('importDP.R')
source('importDP.R')
?coxpath()
?predict.coxpath
q =1
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
coxreg <- list(0)
coxreg$x <- Y.tmp
coxreg$time <- exp(time.tmp)
coxreg$status <- censoring.tmp
path <- coxpath(data = coxreg)
path4lambda2
path$lambda2
path$lambda
path$loglik
plot(path$loglik)
s= length(path$lambda)
s
f.reg <- predict(object = path, data = coxreg, s = 10, type =  "coxph", mode = "lambda")
predict(object = path, data = coxreg, type =  "coxph", mode = "lambda")
predict(object = path, data = coxreg, s =10,type =  "coxph", mode = "lambda")
predict(object = path, data = coxreg, s =20,type =  "coxph", mode = "lambda")
predict(object = path, data = coxreg, s =5,type =  "coxph", mode = "lambda")
q =2
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
coxreg <- list(0)
coxreg$x <- Y.tmp
coxreg$time <- exp(time.tmp)
coxreg$status <- censoring.tmp
path <- coxpath(data = coxreg)
f.reg <- predict(object = path, data = coxreg, s =10,type =  "coxph", mode = "lambda")
f.reg
path$step.length
path$aic
plot(path$aic)
path$new.A
path$meanx
path$sdx
cv.path <- cv.coxpath(data = coxreg, mode = "lambda" )
cv.path
path <- coxpath(data = coxreg)
plot(path)
summary(path)
brier.km.pcox <- c(0)
q
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
coxreg <- list(0)
coxreg$x <- Y.tmp
coxreg$time <- exp(time.tmp)
coxreg$status <- censoring.tmp
path <- coxpath(data = coxreg)
f.reg <- predict(object = path, data = coxreg, s =10,type =  "coxph", mode = "lambda")
fit.coxregph <-  survfit(f.reg)
sbrier(Surv(fit.coxregph$time,fit.coxregph$n.event), fit.coxregph$surv)
fit.coxregph
fit.coxregph$time
fit.coxregph$surv
fit.coxregph <-  survfit(f.reg, newdata = as.data.frame(Y.tmp[,1:D])
)
fit.coxregph <-  survfit(f.reg, newdata = as.data.frame(Y.tmp[,1:D]))
fit.coxregph$surv
sbrier(Surv(fit.coxregph$time,fit.coxregph$n.event), fit.coxregph$surv)
brier.km.pcox <- c(0)
######## Penalized Cox PH ###########################################3
for ( q in 1:F){
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
coxreg <- list(0)
coxreg$x <- Y.tmp
coxreg$time <- exp(time.tmp)
coxreg$status <- censoring.tmp
path <- coxpath(data = coxreg)
f.reg <- predict(object = path, data = coxreg, s =10,type =  "coxph", mode = "lambda")
fit.coxregph <-  survfit(f.reg, newdata = as.data.frame(Y.tmp[,1:D]))
brier.km.pcox[q] <- sbrier(Surv(fit.coxregph$time,fit.coxregph$n.event), fit.coxregph$surv)[[1]]
}
brier.km.pcox
brier.km.paft <- c(0)
q =2
ind <- which((gr.km$cluster) == q)
time.tmp <- time[ind]
censoring.tmp <- censoring[ind]
Y.tmp <- Y[ind,]
reg <- cv.glmnet(x = Y.tmp, y = time.tmp, family = "gaussian")
linear.pred <- predict(object =reg, newx = Y.tmp, s= "lambda.min")
coeff.pred <- coef(object =reg, newx = Y.tmp, s= "lambda.min")
rel.coeff <- coeff.pred[2:(D+1)]
ind.rel <- which(rel.coeff !=0)
library(glmnet)
reg <- cv.glmnet(x = Y.tmp, y = time.tmp, family = "gaussian")
linear.pred <- predict(object =reg, newx = Y.tmp, s= "lambda.min")
coeff.pred <- coef(object =reg, newx = Y.tmp, s= "lambda.min")
rel.coeff <- coeff.pred[2:(D+1)]
ind.rel <- which(rel.coeff !=0)
rel.coeff
